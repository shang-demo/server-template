const Promise = require('bluebird');
const path = require('path');
const fs = Promise.promisifyAll(require('fs'));

const projectPath = path.join(__dirname, '../');
const serverPath = path.join(projectPath, 'src');
const autoGenerateDir = path.join(projectPath, 'config/typings/');
const autoGeneratePath = path.join(projectPath, 'config/typings/shang-auto-generate.d.ts');

function filePathOneLayer(modelsPath) {
  return Promise.try(() => {
    return fs.readdirAsync(modelsPath);
  }).then((fileNames) => {
    return Promise.map(fileNames, (fileName) => {
      let filePath = path.join(modelsPath, fileName);

      let extname = path.extname(filePath);
      if (extname !== '.js') {
        return null;
      }

      return fs.statAsync(filePath).then((stat) => {
        return {
          basename: fileName.replace(/\.js/i, ''),
          name: fileName,
          path: filePath,
          stat,
        };
      });
    }).filter((file) => {
      return file && file.stat && file.stat.isFile();
    });
  });
}

function ensureTypingDir() {
  return fs.mkdirAsync(autoGenerateDir).catch((e) => {
    if (e.code === 'EEXIST') {
      return Promise.resolve();
    }
    return Promise.reject(e);
  });
}

function getServicesDeclare() {
  return filePathOneLayer(path.join(serverPath, 'services'))
    .map((serviceFile) => {
      return `declare let ${serviceFile.basename} = global.${serviceFile.basename};`;
    })
    .then((arr) => {
      return arr.join('\n');
    });
}

function getModelsDeclare() {
  return filePathOneLayer(path.join(serverPath, 'models'))
    .map((modelFile) => {
      return `declare let ${modelFile.basename} = require('mongoose').Model;`;
    })
    .then((arr) => {
      return arr.join('\n');
    });
}

function getGlobal() {
  return Promise.try(() => {
    return "declare let _ = require('lodash');\ndeclare let Promise = require('bluebird');\n";
  });
}

function getErrors() {
  let errors = require(path.join(serverPath, 'config/errors')).errors;
  let str = 'let Errors: {\n  OperationalError(): void,';

  return Promise.map(Object.keys(errors), (key) => {
    return `  ${key}(extra?: object, message?: string): Error,`;
  }).then((arr) => {
    return `${str}\n${arr.join('\n')}\n}\ndeclare let Errors: Errors;`;
  });
}

function getMKoa() {
  return Promise.try(() => {
    return `      
declare let mKoa = {
  config: require('config'),
  environment: {},
  graphql: {
    wrapperPolicy: function,
    schema: object,
    routes: function,
  },
  socketIO: {
    get: function,
    getRoomId: function,
    emit: function,
    addConnectionListener: function,
    removeConnectionListener: function,
  },
  rabbitmq: {
    addConsume: function,
    publish: function,
  },
};
`;
  });
}

function globalLogger() {
  return Promise.try(() => {
    return "declare let logger = require('pino')();";
  });
}

function init() {
  return ensureTypingDir()
    .then(() => {
      return Promise.all([
        getGlobal(),
        getErrors(),
        globalLogger(),
        getModelsDeclare(),
        getServicesDeclare(),
        getMKoa(),
      ]);
    })
    .then((arr) => {
      return fs.writeFileAsync(autoGeneratePath, arr.join('\n'));
    });
}

if (process.argv && process.argv[2] && process.argv[2] === 'init') {
  init();
}

module.exports = {
  init,
};
